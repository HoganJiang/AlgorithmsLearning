#### 动态规划  
    1. 练习题一：机器人走路问题   --Exercise01.java
    2. 练习题二：拿纸牌问题  --Exercise02.java
    3. 练习题三：背包问题 --Exercise03.java
        -关于递归如何确定basecase的一些思考：
            1) basecase确定有点类似数电知识中的约束条件：对于所有的输入组合来说，有些组合一定不可能发生，
                例如：一个电梯不可能即是停止，又是上升，或是下降的状态。而确定basecase的逻辑就是，当不
                可能的情况组合出现时，应该要对其作处理。
            2) 当面临一个新问题应该分析：
                - 最中答案的求解与哪些变量有关？
                    --子问题：如何找出相关的变量？(参考递归尝试模型)
                - 相关变量的一个，或组合中哪些是无效的，当无效的组合条件发生时，应该怎样处理？
                    --处理方式：退出不返回任何值，返回0，返回负值
                        ---子问题：返回值应该怎样处理？
        
        -递归basecase外的代码逻辑都是对相关变量有效时，考虑对当前元素可能性情况的处理。
                
        -递归如何改成记忆化搜索？
        (1) 分析递归函数的依赖，检查是否存在重复解，若存在重复解，则进行第二步
        (2) 找出变化的参数，以及其个数，以此创建二维或多维的缓存表

        -记忆化搜索又如何改写成标准的动态规划？
        (1) 分析可变参数的个数，以及其取值范围，创建动态规划表
        (1) 分析BaseCase，初始化动态规划的表的位置
        (2) 分析最终要返回的结果的位置
        (3) 分析普遍位置的值应该怎么填

    4. 练习题四：规定1和A对应、2和B对应、3和C对应...那么一个数字字符串比如"111”就可以转化为:"AAA"、"KA"和"AK"
        给定一个只有数字字符组成的字符串str，返回有多少种转化结果 --Exercise04.java

    5.  尝试模型：
        练习题五：给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文arr每一个字符串，代表一张贴纸，
        你可以把单个字符剪开使用，目的是拼出str来返回需要至少多少张贴纸可以完成这个任务。
        例子：str= "babac"，arr = {"ba","c","abcd"} ba + ba + c  3  abcd + abcd 2  abcd+ba 2
        所以返回2  --Exercise05.java

    6. 样本对立模型: 最大公共子序列问题    --Exercise06.java

    7. 范围尝试模型：给定一个字符串str，返回这个字符串的最长回文子序列长度 --Exercise07.java

    8. 马跳棋盘问题       --Exercise08.java

    9. 咖啡机问题        --Exercise09.java

        