#### 1. 并查集
    （1）定义：
        1）有若干个样本a、b、c、d…类型假设是V
        2）在并查集中一开始认为每个样本都在单独的集合里
        3）用户可以在任何时候调用如下两个方法：
            boolean isSameSet(V x, V y) : 查询样本x和样本y是否属于一个集合
            void union(V x, V y) : 把x和y各自所在集合的所有样本合并成一个集合
        4） isSameSet和union方法的代价越低越好
    （2）原理：
        1）每个节点都有一条往上指的指针
        2）节点a往上找到的头节点，叫做a所在集合的代表节点
        3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个
        4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可
    （3）练习题：一个学生分别三个属性（身份ID,B站id，githubid）。现在有一个学生集合，规定每个学生只要有一个元素一一匹配，
        就认为这是同一个学生，求这个集合中有多少个学生。 -- Exercise02.java  

#### 2. 图
    2.1 图的定义：任意两个点构成一条边，这两点与边构成的数据结构就称为图。
    2.2 图的分类：图又可以分为有向图与无向图，带边的图称为有向图，不带边的图可以称为无向图。无向图也可以用有向图来表示，
        即是两个图之间相互指向自己，就称为无向图。
    2.3 图的表示：图是有点和线构成，可以有环，也可以无环，甚至有指向自己的环。一般图有两种表示方式，一是邻接表法，二是邻结
        矩阵法。
        2.3.1）邻接表法: 用一个表记录图中每个节点直接指向的节点，若指向的节点是有权重的，我们可以将指向的节点与权重进行封装
                然后记录在表中。
        2.3.2）邻接矩阵法：设一个图有N个节点，每个节点有或者无指向下个节点的权重。用N个节点组成一个NXN的二维矩阵，矩阵的每个
                元素代表两点之间的距离。每个节点与自己的距离记录为0，两个节点之间不存在相互指向的关系，则记为正无穷，有存在
                相互指向的关系，则记录相互间的距离。
    2.4 图的表示的套路：能够表示图的结构有非常多，通常情况下，我们不能为每一种结构都实现一个算法。因此，比较好的做法就是将
        每个表示图的结构先转化成自己的练得非常熟练的图的结构的形式，然后分别实现图的各类算法，最后根据用户的提供的图的结构
        输出用户想要的结果。
    2.5 图的描述: 
        2.5.1）节点的描述
        2.5.2）边的描述
        2.5.3）图的描述
    2.6 练习题：
        2.6.1）宽度优先遍历：以某个节点为遍历的开始点，首先遍历它的直接邻居，然后遍历距离它第二近的邻居节点，
                直到最后。 -- Exercise03.java
        2.6.2）深度优先遍历：以某个节点为遍历的开始点，然后遍历它的直接邻居，结束遍历它直接邻居的直接邻居，直到一条路径没有
                直接邻居或者组后的直接邻居为自己。 --Exercise04.java
        2.6.3）拓扑排序：基于有向无环图，图中的每个节点都依赖于上个节点，按照依赖关系依次处理图中的每个节点。在算法处理上，
                首先找到入度为0的点，打印该点，然后删除该点边的影响，接着找到入度为0的点，再删掉该点边的影响，如此循环
                往复。 --Exercise05.java
        2.6.4）最小生成树算法：
                (1) kruskalMST  --Exercise06.java
                    1）总是从权值最小的边开始考虑，依次考察权值依次变大的边
                    2）当前的边要么进入最小生成树的集合，要么丢弃
                    3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边
                    4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边
                    5）考察完所有边之后，最小生成树的集合也得到了
                (2) Prim --Exercise07.java
                (3) Dijkstra
                    1) Dijkstra解决的问题：在一个权重不为负数的图中，给定一个出发点，求从这个点出发，到所有点的距离最短距离，
                        如果这个点无法到达一个节点，则说明这个点到这个节点的距离是正无穷。 --Exercise08.java