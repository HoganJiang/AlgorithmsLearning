#### 1. 二叉树
   二叉树的先序，中序，后序遍历 -- 见Exercise01.java  
   ~~~
   （1）先序：任何子树的处理顺序是，先头节点，再左子树，然后右子树
   （2）中序：任何子树的处理顺序是，先左子树，再头节点，然后右子树
   （3）后序：任何子树的处理顺序是，先左子树，再右子树，然后头节点
   ~~~  
   递归序 ——二叉树的先序，中序，后续的基础
   ~~~
   （1）递归序：保证每棵树的任意节点都会打印三次，它能保证任意节点收集左子树的信息，然后收集右子树的信息，最后合并
   （2）先序：基于递归序，打印每个节点第一次出现的值
   （3）中序：基于递归序，打印每个节点第二次出现的值
   （4）后序：基于递归徐，打印每个节点第三次出现的值
   ~~~  
   非递归的方式实现二叉树的先序，中序，后序遍历 --见Exercise02.java  
   ~~~
   （1）任何递归函数都可以改成非递归
   （2）自己设计压栈来实现
   （3）先序遍历的算法：
      1）弹出节点就打印
      2）如有右节点，压入右节点
      3）如有左节点，压入左节点
   （4）后续遍历算法：
      1）弹出节点就压入另一个准备好的栈
      2）如有左节点，压入左节点
      3）如有又节点，压入右节点
      4）依次弹出另一个栈的值
   （5）中序遍历算法：
      1）根据头节点一直向左树遍历并压栈
      2）如果通过1）没有节点，则弹出栈中的节点，并打印该节点值，且寻找右子树
      3）继续回到1）往下执行
   ~~~    
   实现二叉树的宽度优先遍历  
   ~~~
   （1）用队列实现 ----见Exercise03.java
   （2）求一颗树的最大宽度  --见Exercise04.java
   ~~~
   二叉树的序列化与反序列化       
   ~~~  
   ~~~  