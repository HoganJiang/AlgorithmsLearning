#### 1. 前缀树  
   定义：前缀树也称为字典树，本质上是用于保存关联数组的多叉树。  
   性质：  
   ~~~~
   （1）前缀树的键通常是字符串
   （2）根节点是空节点，且每个子孙节点不存储实际的键值仅于节点的位置相关  
   （3）一个节点的所有子孙都有相同的前缀，除了叶子节点和内部的节点外，不是每个节点都能找到键值  
   ~~~~
   原理：  
   ~~~
   （1）节点记录字符串经过节点标记，字符串结束标记，以及关联数组
   （2）沿途经过节点，经过节点标记+1，节点结束，结束标记+1
   （3）字符串记录在经过的路径上，如果有路径存在，则重复利用路径，如果没有，则重新创建路径
   ~~~
   API设计 - 见Exercise01.java：  
   ~~~
   (1) void insert(String str)  添加某个字符串，可以重复添加，每次算1个  
   (2) void delete(String str)  删掉某个字符串，可以重复删除，每次算1个
   (3) int search(String str)  查询在结构中存在多少个要搜索的字符串
   (4) int prefixCount(String str) 查询有多少个字符串，是以str做前缀的
   ~~~
   复杂度分析：时间复杂度是O(|S|),空间复杂度O(|T| * ∑)   
   应用：  
   ~~~
   （1）求某个字符串的出现的次数
   （2）求以某个字符串作为前缀的字符串出现的次数  
   （3）如果具备前缀树的特征，则可以往前缀树中添加跟多的标记信息来支持相关的功能
   ~~~
#### 2. 计数排序  
   定义：  
   ~~~
   存在一个数组a，申请一个辅助数组c，c中第i位置的值是a中等于i的个数，将i按照顺序以及个数依次排序，使得原数组a有序。
   ~~~
   性质：
   ~~~
   （1）适用于对类似[0,200]等范围较小的整数排序
   （2）申请的辅助数组c的长度满足最大值减最小值的加1的关系
   ~~~  
   原理：
   ~~~
   （1）申请长度为原数组最大值加1的辅助数组  
   （2）迭代原数组中的每个元素，累加每个元素出现的频次，并将该元素的频次记录在辅助数组中对应的位置，如：原数组中10的频次为3，则在辅助数组中索引为10的位置存储3
   （3）将辅助数组的索引以从小到大的顺序，按照出现的频次依次拷贝回原数组中，使得原数组最终有序
   ~~~  
   API设计： 
   ~~~
   （1）void countingSort(int[]arr);
   ~~~  
   复杂度分析：  
   ~~~
   （1）时间复杂度：O(N)
   （2）额外空间复杂度：O(N)
   ~~~
   应用：
   ~~~
   用于对于小范围如[0,100]的数据的排序
   ~~~  
##### 3. 基数排序  
   定义：  
   ~~~
   基数排序是将数组中的每个元素按照先从低位入桶，再出桶，再次高一位将元素入桶，如此周而复始对数组进行排序的过程。
   ~~~  
   性质：  
   ~~~
   （1）基数排序是基于非负的10进制整数的排序
   ~~~  
   原理：  
   ~~~
   （1）找到样本中数据的最大值，记录其位数，其它元素位数不足最大值的位数的数，按照高位补0依次补齐直至与最大数的位数一致
   （2）构造长度为10的数组，将每个索引位对应一个队列来存储值，此时的队列也称为桶  
   （3）对原数组按照从左至右的顺序对每个元素从低位到高位划分入桶，首先是按照个位入桶，然后按照先进先出的顺序将数据出桶，然后按照十位入桶，出桶规则一致，周而复始，直到按照最高位入桶
   ~~~  
   API设计：
   ~~~
   void radixSorting(int[]arr,int l, int r, int digit);
   ~~~  
   复杂度：
   ~~~
   （1）时间复杂度：O(N)
   （2）空间复杂度：O(M)
   ~~~
   应用：
   ~~~
   在样本数据范围较小且适合划分成的桶的情况下，可以运用。
   ~~~
#### 4. 排序算法的总结  
   稳定性：指样本数据中的元素经过排序后，其相对顺序不发生改变  
   各项排序算法的比较：![sort](OnlineCourse/img/sort.PNG)  
##### 5. 排序算法的选择  
   ~~~
   （1）不基于比较的排序，对样本数据有严格的要求，不易改写
   （2）基于比较的排序，只需要规定好两个样本怎么比大小就可以直接复用，且时间复杂度的极限是O(N * lgN)
   （3）不存在时间复杂度是O(N * lgN)且额外空间复杂度低于O(N)，而且还稳定的排序算法
   （4）追求速度选库快排，追求稳定选归并，追求空间最省选堆排
   ~~~  
##### 6. 工程上对排序的改进  
   ~~~
   （1）稳定性考虑：以java中的sort方法为例，在排序之前首先检查类型是基础类型还是引用类型，如果是基础类型，则调用快排，若是引用类型，则调用归并排序； 
   （2）充分利用O(N*logN)和O(N^2)排序各自的优势。
   ~~~
   
   